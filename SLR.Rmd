---
title: "SLR"
author: Maryann Zhao and Leyla Akay
output: word_document
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(message=FALSE, warning=FALSE, fig.height=3, fig.width=5, fig.align = "center")
library(dplyr)
library(ggplot2)
library(infer)
library(skimr)
library(broom)
library(mosaic)
library(knitr)
library(readr)
options(digits=3)
```

##Introduction
We are studying a dataset of movies, that contains information about their languages, actors, genres, etc. For this project, our variables of interest are budget (in US Dollars) and popularity (based on number of votes per day, and number of views and favorites). We are interested in determining whether there is a linear relationship between the two, and if so, the nature of the relationship. 

##Hypotheses
Our null hypothesis is that there is no relationship between budget and popularity; our alternative hypothesis is that there is a positive relationship between budget and popularity. That is, $\beta_1 > 0$. 

##Assumptions for linear regression:
1. Linearity
An initial plot of budget values vs. popularity indicates a linear shape. We transformed both explanatory and response variables with a log function, and noticed that the plot became more linear, so we decided to keep the transformation for the remaining tests.

2. Independence
We are assuming mathematical independence--that is, spending more money doesn't necessarily translate to increased popularity, or vice versa. 

3. Normality & Constant Errors
To check this, we plotted the residuals and looked at the symmetry. The residuals appear to be symmetrically distributed around 0, with some increased scattering at lower values of budget. The residuals appear more concentrated around 0, and are all in the range of +/- 4.  

```
r, eval=TRUE

```
##Testing $\beta_1$
To determine whether the alternative hypothesis holds, we determined a 95% confidence interval for $\beta_1$. We found the CI was between 0.317 and 0.353. Because both variables had been logged-transformed, this means that a doubling of budget would be consistent with a multiplicative change in median of popularity between:
$2^(0.317) and 2^(0.353)$, which is consistent with 1.25 and 1.28.

##Plotting variables
We were interested in movies with 1M$ budgets, since these are relatively low compared to many block-buster films, but many appear to achieve comprable levels of popularity. In this situation, we thought of budget as the explanatory variable, since it's determined before popularity, so although budget doesn't necessarily explain popularity, it wouldn't be possible for popularity to inform budget. 
(Come back to plot)

##Assessing the fit
The r-squared value is 0.262. The residuals (plotted above) appear to be evenly distributed. Therefore, we believe our model accurately describes the data. 

##Conclusion
In general, the positive relationship was expected. The decreased variability at very high budgets was interesting, but upon further reflection we guess it makes sense. Movies that spend tens of millions of dollars probably attract high-profile actors and have lots of advertising campaigns, which probably increase the popularity. 

##Pairs: Simultaneous Inference
To find the mean and prediction intervals for all n values, we used the Bonferroni, Working-Hotelling, and Scheff√© methods. 

It's important to control for multiple comparisons, because the more variables you add, the more likely you are to get a "significant" difference, even though there isn't a real effect.

It's most useful to use 


```{r, eval=TRUE}
tmdb_5000_movies <- read_csv("~/LM HW/SLM_Project/tmdb_5000_movies-OG.csv")
tmdb2 <- read_csv("tmdb_2.csv")

library(readr)
library(purrr)
df <- readr::read_csv("tmdb_5000_movies-OG.csv")
genres.table <- purrr::map(df$genres, jsonlite::fromJSON)
genres.table <- purrr::map_df(genres.table, ~data.frame(x=.x), .id="movieID")
```

```{r, eval=TRUE}
#plot of log popularity vs. log budget
ggplot(tmdb2, aes(x=budget, y=popularity)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10()

#residual plot
bud2 <- tmdb2 %>% 
  select(popularity, budget) %>%
  filter(budget > 0, popularity > 0)
pop.log <- log(bud2$popularity)
bud.log <- log(bud2$budget)
movies <- lm(pop.log ~ bud.log, data = tmdb2)
ggplot (movies, aes(x=fitted(movies), y=resid(movies))) + geom_point()
```

```{r, eval=TRUE}
#Attempt at CI and PI for 1 mill budget
broom::tidy(movies, conf.int = TRUE, conf.level = 0.95)
mill <- data.frame(bud.log=c(13.8))
crit_val <- qt(.95, glance(movies)$df.resid)
movie.pred <- broom::augment(movies, newdata=mill, type.predict = "response")
.se.pred <- sqrt(glance(movies)$sigma^2 + movie.pred$.se.fit)

movie.pred <- movie.pred %>%
mutate(lower_CI = .fitted - crit_val * .se.fit,
upper_CI = .fitted + crit_val * .se.fit)

movie.pred <- movie.pred %>%
  mutate(lower_PI = .fitted - crit_val * .se.pred,
         upper_PI = .fitted + crit_val * .se.pred, 
         lower_CI = .fitted - crit_val * .se.fit, 
         upper_CI = .fitted + crit_val * .se.fit)

movie.pred
```

```{r, eval=TRUE}
#R squared value
summary(movies)$r.squared
```

```{r, eval=TRUE}
#install.packages("gridExtra")
library(robustbase)
library(investr)
library(ggplot2)
library(gridExtra)

movie_gl <- broom::glance(movies)
movie_sig <- dplyr::pull(movie_gl, sigma)

movie_pred <- broom::augment(movies) %>%
  mutate(.se.pred = sqrt(movie_sig^2 + .se.fit^2)) %>%
  mutate(lower_PI = .fitted - crit_val*.se.pred,
  upper_PI = .fitted + crit_val*.se.pred,
  lower_CI = .fitted - crit_val * .se.fit,
  upper_CI = .fitted + crit_val * .se.fit)

movie_pred %>% head()

ggplot(movie_pred, aes(x = bud.log, y =pop.log)) + geom_point() +
  stat_smooth(method = "lm", se = FALSE) +
  geom_ribbon(aes(ymin = lower_PI, ymax = upper_PI), alpha = .2) +
  geom_ribbon(data = movie_pred, aes(ymin = lower_CI, ymax = upper_CI), alpha = .2, fill = "red") +
  xlab("log(budget)") + ylab("log(popularity)")
```

```{r, eval=TRUE}
num_int <- 3
crit_Bonf <- qt((1-.975)/num_int, glance(movies)$df.resid)
crit_WH <- sqrt(2*qf(.95, num_int, glance(movies)$df.resid))

movie_Bonf <- broom::augment(movies) %>%
mutate(.se.pred = sqrt(movie_sig^2 + .se.fit^2)) %>%
mutate(lower_PI = .fitted - crit_Bonf*.se.pred,
upper_PI = .fitted + crit_Bonf*.se.pred,
lower_CI = .fitted - crit_Bonf * .se.fit,
upper_CI = .fitted + crit_Bonf * .se.fit)

movie_Bonf %>% head()

ggplot(movie_Bonf, aes(x = bud.log, y =pop.log)) + geom_point() +
  stat_smooth(method = "lm", se = FALSE) +
  geom_ribbon(aes(ymin = lower_PI, ymax = upper_PI), alpha = .2) +
  geom_ribbon(data = movie_Bonf, aes(ymin = lower_CI, ymax = upper_CI), alpha = .2, fill = "red") +
  xlab("log(budget)") + ylab("log(popularity)")

```

```{r, eval=TRUE}
working.hotelling.bonferroni.intervals <- function(x, y) {
  y <- as.matrix(y)
  if (ncol(y) > 1) {
    stop('y must be a vector')
  }
  x <- as.matrix(x)
  if (ncol(x) > 1) {
    stop('x must be a vector')
  }
  n <- length(y)
  if (n != length(x)) {
    stop('x and y must be the same length')
  }
  # Get the fitted values of the linear model
  fit <- lm(y ~ x)
  fit <- movies$fitted.values
  
  # Find standard error as defined above
  se <- sqrt(sum((y - fit)^2) / (n - 2)) * 
    sqrt(1 / n + (x - mean(x))^2 / 
           sum((x - mean(x))^2))

  # Calculate B and W statistics for both procedures.
  W <- sqrt(2 * qf(p = 0.95, df1 = 2, df2 = n - 2))
  B <- 1-qt(.95/(2 * 3), n - 1)

  # Compute the simultaneous confidence intervals
  
  # Working-Hotelling
  wh.upper <- fit + W * se
  wh.lower <- fit - W * se
  
  # Bonferroni
  bon.upper <- fit + B * se
  bon.lower <- fit - B * se
  
  xy <- data.frame(cbind(x,y))
  
  # Plot the Working-Hotelling intervals
  wh <- ggplot(xy, aes(x=x, y=y)) + 
    geom_point(size=2.5) + 
    geom_line(aes(y=fit, x=x), size=1) + 
    geom_line(aes(x=x, y=wh.upper), colour='blue', linetype='dashed', size=1) + 
    geom_line(aes(x=x, wh.lower), colour='blue', linetype='dashed', size=1) +
    labs(title='Working-Hotelling')
  
  # Plot the Bonferroni intervals
  bonn <- ggplot(xy, aes(x=x, y=y)) + 
    geom_point(size=2.5) + 
    geom_line(aes(y=fit, x=x), size=1) + 
    geom_line(aes(x=x, y=bon.upper), colour='blue', linetype='dashed', size=1) + 
    geom_line(aes(x=x, bon.lower), colour='blue', linetype='dashed', size=1) +
    labs(title='Bonferroni')
  
  grid.arrange(wh, bonn, ncol = 2)
  
  # Collect results of procedures into a data.frame and return
  res <- data.frame(round(cbind(W, B), 3), row.names = c('Result'))
  colnames(res) <- c('W', 'B')
  
  return(res)
}
x <- log(bud2$budget)
y <- log(bud2$popularity)
working.hotelling.bonferroni.intervals(x, y)

scheffe.bonferroni.intervals <- function(x, y) {
  y <- as.matrix(y)
  if (ncol(y) > 1) {
    stop('y must be a vector')
  }
  x <- as.matrix(x)
  if (ncol(x) > 1) {
    stop('x must be a vector')
  }
  n <- length(y)
  if (n != length(x)) {
    stop('x and y must be the same length')
  }
  # Get the fitted values of the linear model
  fit <- lm(y ~ x)
  fit <- movies$fitted.values
  
  # Find standard error as defined above
  se <- sqrt(sum((y - fit)^2) / (n - 2)) * 
    sqrt(1 / n + (x - mean(x))^2 / 
           sum((x - mean(x))^2))

  # Calculate B and W statistics for both procedures.
  W <- sqrt(2 * qf(p = 0.95, df1 = 2, df2 = n - 2))
  B <- 1-qt(.95/(2 * 3), n - 1)

  # Compute the simultaneous confidence intervals
  
  # Working-Hotelling
  wh.upper <- fit + W * se
  wh.lower <- fit - W * se
  
  # Bonferroni
  bon.upper <- fit + B * se
  bon.lower <- fit - B * se
  
  xy <- data.frame(cbind(x,y))
  
  # Plot the Working-Hotelling intervals
  wh <- ggplot(xy, aes(x=x, y=y)) + 
    geom_point(size=2.5) + 
    geom_line(aes(y=fit, x=x), size=1) + 
    geom_line(aes(x=x, y=wh.upper), colour='blue', linetype='dashed', size=1) + 
    geom_line(aes(x=x, wh.lower), colour='blue', linetype='dashed', size=1) +
    labs(title='Working-Hotelling')
  
  # Plot the Bonferroni intervals
  bonn <- ggplot(xy, aes(x=x, y=y)) + 
    geom_point(size=2.5) + 
    geom_line(aes(y=fit, x=x), size=1) + 
    geom_line(aes(x=x, y=bon.upper), colour='blue', linetype='dashed', size=1) + 
    geom_line(aes(x=x, bon.lower), colour='blue', linetype='dashed', size=1) +
    labs(title='Bonferroni')
  
  grid.arrange(wh, bonn, ncol = 2)
  
  # Collect results of procedures into a data.frame and return
  res <- data.frame(round(cbind(W, B), 3), row.names = c('Result'))
  colnames(res) <- c('W', 'B')
  
  return(res)
}
```

